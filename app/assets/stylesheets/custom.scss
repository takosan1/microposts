@import "bootstrap-sprockets";
@import "bootstrap";

/* universal */

body {
    padding-top: 60px;
}

section {
    overflow: auto;
}

textarea {
    resize: vertical;
}

.center {
    text-align: center;
}

.center h1 {
    margin-bottom: 10px;
}

/* typography */

h1, h2, h3, h4, h5, h6 {
    line-height: 1;
}

h1 {
    font-size: 3em;
    letter-spacing: -2px;
    margin-bottom: 30px;
    text-align: center;
}

h2 {
    font-size: 1.2em;
    letter-spacing: -1px;
    margin-bottom: 30px;
    text-align: center;
    font-weight: normal;
    color: #777;
}

p {
    font-size: 1.1em;
    line-height: 1.7em;
}

/* header */

#logo {
    float: left;
    margin-right: 10px;
    font-size: 1.7em;
    color: #fff;
    text-transform: uppercase;
    letter-spacing: -1px;
    padding-top: 9px;
    font-weight: bold;
}

#logo:hover {
    color: #fff;
    text-decoration: none;
}

/* mixins, variables, etc. */

$gray-medium-light: #eaeaea;

@mixin box-sizing {
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
}

/* forms */

input, textarea, select, .uneditable-input {
    border: 1px solid #bbb;
    width: 100%;
    margin-bottom: 15px;
    @include box_sizing;
}

input {
    height: auto !important;
}

#error_explanation {
  color: red;
  ul {
    color: red;
    margin: 0 0 30px 0;
  }
}

.field_with_errors {
  @extend .has-error;
  .form-control {
    color: $state-danger-text;
  }
}


Lesson7
Twitterクローン

1. はじめに

メッセージボードのレッスンで簡単なWebアプリケーションの作成を行いましたが、このレッスンでは、より本格的なWebアプリケーションとして、Twitterクローンの作成を行います。

基本的な機能として、以下の実装を行います。

ユーザーが新規登録・ログインできる
つぶやき（マイクロポスト）を投稿できる
他のユーザーをフォローして、タイムラインを表示できる
このレッスンで説明する内容は、オリジナルのWebアプリケーションを作成したり、仕事でRailsを使ってプログラミングを行う上でよく使うテクニックを含んでいます。実際に手を動かしながら分からない点は調べたりメンターに質問したりして理解していきましょう。

2. アプリケーションの新規作成

2.1 初期設定

Cloud9上のターミナルから以下を実行して、micropostsという名前でアプリケーションを新規作成します。
（今回は後からbundle installコマンドを実行するので、rails new micropostsに-Bオプションを指定することで、bundle installが自動で実行されないようにしています。）

$ rails new microposts -B
ファイルの生成が完了したらcd microposts/を実行してmicropostsフォルダに移動します。

ここまで出来たところで、Gitリポジトリの初期化を行います。

$ git init
$ git add .
$ git commit -m "first commit"
メッセージボードと同じ手順でGitHubにmicropostsというリポジトリを作成します。

GitHubの指示に従って、作成したリポジトリにアプリケーションをpushします。

$ git remote add origin git@github.com:[あなたのアカウント名]/microposts.git
$ git push origin master
2.2 ジェネレータの設定

今回は、テストコードとJavaScript、CSS(SCSS)、ヘルパのファイルを自動生成しないので、Rails側であらかじめ設定しておきます。

アプリケーションの設定ファイルの、class Application < Rails::Applicationの中に以下のように設定します。

config/application.rb

...
module Microposts
  class Application < Rails::Application
    ...

    config.generators do |g|
      g.stylesheets false
      g.javascripts false
      g.helper false
      g.test_framework false
    end
  end
end
3. レイアウトのセットアップ

3.1 Bootstrapの追加

今回はBootstrapを使ってレイアウトを行いますので、Gemfileの25行目付近にgem 'bootstrap-sass'を追加します。
また、20行目付近のgem 'turbolinks'は今回は使用しないので、行頭に#を追加してコメントアウトしておきます。

Gemfile

...
# gem 'turbolinks'
# Build JSON APIs with ease. Read more: https://github.com/rails/jbuilder
gem 'jbuilder', '~> 2.0'
# bundle exec rake doc:rails generates the API under doc/api.
gem 'sdoc', '~> 0.4.0', group: :doc

gem 'bootstrap-sass'

# Use ActiveModel has_secure_password
# gem 'bcrypt', '~> 3.1.7'
...
上記の内容で保存したらbundle installを実行します。

3.2 カスタムSCSSの追加

Railsはコントローラを生成するごとにSCSSファイルを生成しますが、今回はBootstrapをベースにして1つのSCSSファイルでデザインを行うことにします。app/assets/stylesheets/内にcustom.scssファイルを以下の内容で作成します。（拡張子がscssとなっていることに注意してください。）

app/assets/stylesheets/custom.scss

@import "bootstrap-sprockets";
@import "bootstrap";

/* universal */

body {
  padding-top: 60px;
}

section {
  overflow: auto;
}

textarea {
  resize: vertical;
}

.center {
  text-align: center;
}

.center h1 {
  margin-bottom: 10px;
}

/* typography */

h1, h2, h3, h4, h5, h6 {
  line-height: 1;
}

h1 {
  font-size: 3em;
  letter-spacing: -2px;
  margin-bottom: 30px;
  text-align: center;
}

h2 {
  font-size: 1.2em;
  letter-spacing: -1px;
  margin-bottom: 30px;
  text-align: center;
  font-weight: normal;
  color: #777;
}

p {
  font-size: 1.1em;
  line-height: 1.7em;
}

/* header */

#logo {
  float: left;
  margin-right: 10px;
  font-size: 1.7em;
  color: #fff;
  text-transform: uppercase;
  letter-spacing: -1px;
  padding-top: 9px;
  font-weight: bold;
}

#logo:hover {
  color: #fff;
  text-decoration: none;
}
最初の行のSCSSの@import宣言でBootstrap関連のモジュールを読み込んで、あとは、micropostsで使用するスタイルを指定しています。

3.3 JavaScriptの設定

app/assets/javascripts/application.jsを開き、最後の3行を以下のように設定します。

app/assets/javascripts/application.js

//= require jquery
//= require jquery_ujs
//= require bootstrap-sprockets
15行目付近の//= require turbolinksの部分は今回は使用しないので削除してください。

3.4 HTMLレイアウト

micropostsの全体で使用するHTMLのレイアウトをapp/views/layouts/application.html.erbで指定します。

app/views/layouts/application.html.erb

<!DOCTYPE html>
<html>
  <head>
    <title>Microposts</title>
    <%= stylesheet_link_tag 'application', media: 'all' %>
    <%= javascript_include_tag 'application' %>
    <%= csrf_meta_tags %>
  </head>
  <body>
    <%= render 'layouts/header' %>
    <div class="container">
      <%= yield %>
    </div>
  </body>
</html>
このファイルでは、アプリケーション全体で読み込むスタイルシート、JavaScriptファイルなどを指定しています。
12行目付近のyieldの部分に各ページの部分テンプレート（erbファイル）が読み込まれます。

<%= render 'layouts/header' %>の部分で読み込むパーシャルを以下のような内容で作成します。

app/views/layouts/_header.html.erb

<header class="navbar navbar-fixed-top navbar-inverse">
  <div class="container">
    <%= link_to "Microposts", '#', id: "logo" %>
    <nav>
      <ul class="nav navbar-nav navbar-right">
        <li><%= link_to "Home",   '#' %></li>
        <li><%= link_to "Help",   '#' %></li>
        <li><%= link_to "Log in", '#' %></li>
      </ul>
    </nav>
  </div>
</header>
ここではリンク先は指定しないので#としてあります。

ここまでできたら、Gitリポジトリにコミットを行ってください。

$ git add .
$ git commit -m "add initial setups"
4. トップページ

4.1 コントローラとルートの作成

スタイルとレイアウトが作成できたので、実際にトップページを作ってみます。
以下を実行します。

$ rails generate controller static_pages home
ここでは、homeというアクション（コントローラのメソッド）を追加するので、コントローラ名の最後に追加しています。
実行した後の出力は以下のようになります。

      create  app/controllers/static_pages_controller.rb
       route  get 'static_pages/home'
      invoke  erb
      create    app/views/static_pages
      create    app/views/static_pages/home.html.erb
      invoke  assets
      invoke    coffee
      invoke    scss
出力を見ると、app/controllers/static_pages_controller.rbというコントローラと、get 'static_pages/home'というルートと、app/views/static_pages/home.html.erbというERBファイルが追加されているのがわかります。

config/routes.rbを開くと以下のようになっています。

config/routes.rb

Rails.application.routes.draw do
  get 'static_pages/home'
  ...
これを、以下のように編集します。(#コメントアウトされた全ての行や空行も削除しておきます）

config/routes.rb

Rails.application.routes.draw do
  root to: 'static_pages#home'
end
このようにすることで、app/views/static_pages/home.html.erbの内容がトップページに表示されるようになります。

4.2 サーバーの起動と表示の確認

ここでRailsサーバーを起動して実際にレイアウトの表示を確認してみます。

Railサーバーを起動するには以下のコマンドを実行します。

$ rails s -p $PORT -b $IP
ターミナルの”Cloud9 Help”のポップアップ上のURLをクリックして、以下のような画面の表示を確認してください。

microposts基本レイアウト

ここまでできたら、ターミナルでCtrl-cでRailsサーバーを停止して、Gitリポジトリにコミットを行ってください。

$ git add .
$ git commit -m "add top page"
5. Userモデル

5.1 モデルの作成

Railsのモデルジェネレータで、ユーザーのモデルを作成します。

$ rails generate model User name email password_digest
      invoke  active_record
      create    db/migrate/20150610062143_create_users.rb
      create    app/models/user.rb
ここで、nameはユーザー名、emailはメールアドレス、password_digestはパスワードを暗号化したものです。

今回は、メッセージボードのときとは異なりstringを指定していませんが、全ての属性は文字列になります。

5.2 マイグレーションの実行

ここで、db/migrate/内のcreate_users.rbで終わるファイル名のマイグレーションファイルを以下のように修正します。

db/migrate/2015XXXXXXXXXX_create_users.rb

class CreateUsers < ActiveRecord::Migration
  def change
    create_table :users do |t|
      t.string :name
      t.string :email
      t.string :password_digest

      t.timestamps null: false

      t.index :email, unique: true # この行を追加
    end
  end
end
ここで、t.index :email, unique: trueでemailにユニークインデックスを追加して、メールアドレスが他と異なるようにしています。

変更を保存したら、マイグレーションを実行します。

$ rake db:migrate
エラーなく実行できたら成功ですので、Gitリポジトリにコミットしておきます。

$ git add .
$ git commit -m "add user model"
6. 新規登録機能

ここで、上記で作成したモデルを使用して、ユーザーの新規登録ができるようにします。

6.1 コントローラの作成

RailsのジェネレータでUsersControllerを作成しておきます。最後にnewをつけるようにしてください。

$ rails generate controller users new
app/controllers/users_controller.rbを以下のように編集して保存します。

app/controllers/users_controller.rb

class UsersController < ApplicationController
  def new
    @user = User.new
  end
end
以下の追加したコードで、Userクラスの新しいインスタンスを作成して、UsersControllerのインスタンス変数@userに代入しています。

@user = User.new
6.2 ルートの作成

config/routes.rbを以下のように書き換えてください。

config/routes.rb

Rails.application.routes.draw do
  root to: 'static_pages#home'
  get 'signup',  to: 'users#new'

  resources :users
end
ターミナルでrake routesを実行すると、以下のようなルートが生成されています。

   Prefix Verb   URI Pattern               Controller#Action
     root GET    /                         static_pages#home
   signup GET    /signup(.:format)         users#new
    users GET    /users(.:format)          users#index
          POST   /users(.:format)          users#create
 new_user GET    /users/new(.:format)      users#new
edit_user GET    /users/:id/edit(.:format) users#edit
     user GET    /users/:id(.:format)      users#show
          PATCH  /users/:id(.:format)      users#update
          PUT    /users/:id(.:format)      users#update
          DELETE /users/:id(.:format)      users#destroy
ルートの以下の部分で/usersに対して、POSTで送信されたデータが、UsersControllerのcreateメソッドで処理されることがわかります。

          POST   /users(.:format)          users#create
また以下の部分で、/signupにアクセスすると、UsersControllerのnewメソッドで処理され、app/views/users/new.html.erbの内容を表示できるようになります。

   signup GET    /signup(.:format)         users#new
config/routes.rbに変更を加えた際には、rake routesを実行して実際に生成されるルートを確認してください。

6.3 フォームの作成

app/views/users/new.html.erbを以下のように編集して保存します。

app/views/users/new.html.erb

<h1>Sign up</h1>

<div class="row">
  <div class="col-md-6 col-md-offset-3">
    <%= form_for(@user) do |f| %>

      <%= f.label :name %>
      <%= f.text_field :name %>

      <%= f.label :email %>
      <%= f.text_field :email %>

      <%= f.label :password %>
      <%= f.password_field :password %>

      <%= f.label :password_confirmation, "Confirmation" %>
      <%= f.password_field :password_confirmation %>

      <%= f.submit "Create my account", class: "btn btn-large btn-primary" %>
    <% end %>
  </div>
</div>
ここで、先ほどのUserモデル生成の際に指定した、nameとemail、そしてこれから実装するパスワードの入力と確認入力のpassword, password_confirmationを指定しています。メッセージボードの回はf.text_fieldを使用しましたが、今度はf.password_fieldを指定しています。これによって、パスワードを入力した際には文字が●●●●●●●●のように伏せられた形で表示されます。

最後の提出ボタンの部分では、Bootstrapのボタンのスタイルを指定しています。

app/assets/stylesheets/custom.scssに以下の行を追加します。

app/assets/stylesheets/custom.scss

/* mixins, variables, etc. */

$gray-medium-light: #eaeaea;

@mixin box_sizing {
  -moz-box-sizing:    border-box;
  -webkit-box-sizing: border-box;
  box-sizing:         border-box;
}

/* forms */

input, textarea, select, .uneditable-input {
  border: 1px solid #bbb;
  width: 100%;
  margin-bottom: 15px;
  @include box_sizing;
}

input {
  height: auto !important;
}
ここは主に見た目の部分なのでコピーアンドペーストするだけで大丈夫です。

Railsサーバーをコマンドrails s -p $PORT -b $IPで起動し、ポップアップのURL/signup（https://xxxxx.c9users.io/signupのようなURL）にアクセスすると、ブラウザでの表示は以下のようになります。

サインアップ画面

6.4 モデルの実装

次は、実際にフォームから送信されたデータを受け取ってユーザーを新規登録する部分の実装に入ります。

has_secure_passwordを有効にする

Railsの標準機能でパスワードつきのモデルを使用できるので、これを有効にします。

まず、Gemfileのgem 'bcrypt'で始まる行のコメントを外して、bundle installを実行します。

Gemfile

# Use ActiveModel has_secure_password
gem 'bcrypt', '~> 3.1.7'
app/models/user.rbに以下のようにhas_secure_passwordメソッドを1行追加します。

app/models/user.rb

class User < ActiveRecord::Base
  has_secure_password
ここで、has_secure_passwordメソッドは、Userモデル以下の機能を追加します。

データベースに安全にハッシュ化（暗号化）されたpassword_digestを保存する。
passwordとpassword_confirmationをモデルに追加して、パスワードの確認が一致するか検証する。
パスワードが正しいときに、ユーザーを返すauthenticateメソッドを提供する。
ここではhas_secure_passwordによって、簡単に認証機能を追加することができるぐらいの理解で大丈夫です。

バリデーションの追加

バリデーションなどを追加する為に、以下のようにapp/models/user.rbを変更します。

app/models/user.rb

class User < ActiveRecord::Base
  before_save { self.email = email.downcase }
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :email, presence: true, length: { maximum: 255 },
                    format: { with: VALID_EMAIL_REGEX },
                    uniqueness: { case_sensitive: false }
  has_secure_password
end
ソースコードの解説は以下の通りです。

2行目で、データの保存前にメールアドレスのアルファベットを小文字にします。before_saveはコールバックと呼ばれ、データの保存が行われる前に指定したブロックまたはメソッドの処理が実行されます。
3行目でnameは空でなく、また、最大50文字になるようにバリデーションを行います。
4行目のVALID_EMAIL_REGEXでメールアドレスの正規表現パターンを定義しています。（正規表現についてはここでは理解しなくも大丈夫です。）
5〜7行目で、emailは空でなく、255文字以内で、VALID_EMAIL_REGEXのパターンに一致し、他と異なるようにバリデーションを行っています。
6.5 コントローラの実装

以下のように、app/controllers/users_controller.rbを実装します。

app/controllers/users_controller.rb

class UsersController < ApplicationController
  ...

  def create
    @user = User.new(user_params)
    if @user.save
    else
      render 'new'
    end
  end

  private

  def user_params
    params.require(:user).permit(:name, :email, :password,
                                 :password_confirmation)
  end
end
ここの#createの部分で、送信されたパラメータの内容をもとに新しい@userのデータを作成しています。
ストロングパラメータで、passwordとpassword_confirmationという、has_secure_passwordで提供されたデータベースにない属性を指定しているのに注意してください。

6.6 エラー表示

ここで、新規登録に失敗した場合のエラー表示の実装を行います。以下のようにapp/views/users/new.html.erbを修正します。

app/views/users/new.html.erb

<h1>Sign up</h1>

<div class="row">
  <div class="col-md-6 col-md-offset-3">
    <%= form_for(@user) do |f| %>
      <%= render 'shared/error_messages', object: f.object %> <!-- ここを追加 -->

      <%= f.label :name %>
      <%= f.text_field :name, class: 'form-control' %>

      <%= f.label :email %>
      <%= f.email_field :email, class: 'form-control' %>

      <%= f.label :password %>
      <%= f.password_field :password, class: 'form-control' %>

      <%= f.label :password_confirmation, "Confirmation" %>
      <%= f.password_field :password_confirmation, class: 'form-control' %>

      <%= f.submit "Create my account", class: "btn btn-primary" %>
    <% end %>
  </div>
</div>
app/views/以下にsharedディレクトリを作成し、以下のような内容で、app/views/shared/_error_messages.html.erbを作成します。

app/views/shared/_error_messages.html.erb

<% if object.errors.any? %>
  <div id="error_explanation">
    <div class="alert alert-danger">
      The form contains <%= pluralize(object.errors.count, "error") %>.
    </div>
    <ul>
    <% object.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
<% end %>
objectには、@userが入ります。ここでは、送信されたデータにエラーがある場合、@user.errorsにエラー内容が入っているのでそれらを取り出してメッセージとして表示している、という理解で大丈夫です。　

app/assets/stylesheets/custom.scssに以下のように追加します。

app/assets/stylesheets/custom.scss

#error_explanation {
  color: red;
  ul {
    color: red;
    margin: 0 0 30px 0;
  }
}

.field_with_errors {
  @extend .has-error;
  .form-control {
    color: $state-danger-text;
  }
}
ここはSCSSの部分なので、コピーアンドペーストで大丈夫です。

実際にブラウザでエラー表示を確認してみましょう。
たとえば、名前を入力しただけで”Creatge my account”のボタンをクリックすると、以下のようなエラー画面になります。

新規登録エラー

エラーメッセージが英語で表示されていますが、ここはこのままで大丈夫です。（余力のある方は、チャレンジ課題で日本語化を行ってください。）

6.7 ユーザー詳細画面

ここで、無事に新規登録した場合は、以下のようなテンプレートがないときの画面になってしまいます。

テンプレートなし

新規登録した場合はユーザーの詳細画面を表示するようにしましょう。

app/views/users/show.html.erbを以下のような内容で作成します。

app/views/users/show.html.erb

<h1>
  <%= gravatar_for @user %>
  <%= @user.name %>
</h1>
gravatar_forメソッドは、Gravatarというサービスに登録された画像から引っ張ってきて、HTMLタグを出力します。

ここで、Railsのヘルパーという機能を使います。ヘルパーはモデルの情報を受け取って表示用の出力（HTMLタグの表示、テキストの出力）を行うメソッドを入れるモジュールです。他にもRailsのモデル・ビュー・コントローラー以外のロジックを記述するのに用いられます。

app/helpers/users_helper.rbを作成して記述します。

app/helpers/users_helper.rb

module UsersHelper
  def gravatar_for(user, options = { size: 80 })
    gravatar_id = Digest::MD5::hexdigest(user.email.downcase)
    size = options[:size]
    gravatar_url = "https://secure.gravatar.com/avatar/#{gravatar_id}?s=#{size}"
    image_tag(gravatar_url, alt: user.name, class: "gravatar")
  end
end
ここでは、メールアドレスからGravatarの画像用のURLを生成してgravatar_urlに代入している、という理解で大丈夫です。最後にはimage_tagメソッドで<img>タグが出力されます。

app/controllers/users_controller.rbにshowメソッドを以下のように実装し、createメソッドの処理を修正します。

app/controllers/users_controller.rb

class UsersController < ApplicationController

  def show # 追加
   @user = User.find(params[:id])
  end
  
  def new
    @user = User.new
  end

  def create
    @user = User.new(user_params)
    if @user.save
      redirect_to @user # ここを修正
    else
      render 'new'
    end
  end

  ...
end
あらかじめルートのでresources :usersを設定していたので、createメソッドの@user.saveの後の

redirect_to @user
の部分は、

redirect_to user_path(@user)
と同じように動作します。

これで、新規登録後にユーザー詳細画面にリダイレクトされるようになりました。

ユーザー詳細

6.8 フラッシュメッセージの追加

Railsで一時的なメッセージ（フラッシュメッセージ）を表示するためにはredirect_toやrenderの前に、flashというハッシュに:success、:alertなどのキーを指定してメッセージを代入します。

app/controllers/users_controller.rbで以下のようにコードを修正します。

app/controllers/users_controller.rb

class UsersController < ApplicationController
  ...

  def create
    @user = User.new(user_params)
    if @user.save
      flash[:success] = "Welcome to the Sample App!"
      redirect_to @user
    else
      render 'new'
    end
  end

  ...
end
フラッシュメッセージを表示するには、app/views/layouts/application.html.erbを以下のように修正します。

app/views/layouts/application.html.erb

<!DOCTYPE html>
<html>
<head>
  <title>Microposts</title>
  <%= stylesheet_link_tag    'application', media: 'all' %>
  <%= javascript_include_tag 'application' %>
  <%= csrf_meta_tags %>
</head>
<body>
 <%= render 'layouts/header' %>
  <div class="container">
    <% flash.each do |message_type, message| %> <!-- ここから -->
      <div class="alert alert-<%= message_type %>"><%= message %></div>
    <% end %> <!-- ここまで追加 -->
    <%= yield %>
  </div>
</body>
</html>
追加した部分では、flashはハッシュなので、eachメソッドでそれぞれのキー（message_type）と値（message）のペアを取り出して、順にアラートを表示しています。

ブラウザで新規登録を行って、以下のような画面になれば完成です。

ユーザー詳細Flash

ここまでできたら、Gitリポジトリにコミットを行ってください。

$ git add .
$ git commit -m "add sign sign up and user detail"
7. ログイン機能

7.1 セッションとは

新規登録ができるようになりましたので、今度はログインできるようにします。

Webアプリケーションでログインする場合は、ログイン情報をセッションとして、サーバーとブラウザに保存します。
今回のアプリケーションでは、Railsで提供されるsessionという特別な変数にユーザーのidを入れることで、ログイン機能を実現します。
ログインの際にはsession[:user_id]にユーザーIDを入れ、ログアウトの際にはsession[:user_id]をnilにします。

7.2 コントローラとルートの作成

上記のsessionへの操作を実現するために、コントローラを作成します。アクションとしてnewを指定しています。

$ rails generate controller sessions new
以下のようにconfig/routes.rbを編集・保存します。

config/routes.rb

Rails.application.routes.draw do
  root to: 'static_pages#home'
  get    'signup', to: 'users#new'
  get    'login' , to: 'sessions#new'
  post   'login' , to: 'sessions#create'
  delete 'logout', to: 'sessions#destroy'

  resources :users
  resources :sessions, only: [:new, :create, :destroy]
end
ここで、login、logoutというパスでそれぞれ、ログイン、ログアウトできるようにしています。

7.3 ビューの作成

app/views/sessions/new.html.erbを以下のような内容で作成します。

app/views/sessions/new.html.erb

<h1>Log in</h1>

<div class="row">
  <div class="col-md-6 col-md-offset-3">
    <%= form_for(:session, url: login_path) do |f| %>

      <%= f.label :email %>
      <%= f.email_field :email, class: 'form-control' %>

      <%= f.label :password %>
      <%= f.password_field :password, class: 'form-control' %>

      <%= f.submit "Log in", class: "btn btn-primary" %>
    <% end %>

    <p>New user? <%= link_to "Sign up now!", signup_path %></p>
  </div>
</div>
ここで、ログインに使う入力欄はメールアドレスとパスワードなので、f.email_field :emailとf.password_field :passwordで　２つの入力欄を作成しています。
email_fieldを用いることで、<input>タグにtype="email"がつき、メールアドレス型式の入力欄になります。
また、form_forの最初の引数に:sessionを取ることで、<input>のname属性がsession[email]、session[password]となります。今回はセッションを作成するので、user[email]、user[password]でないことに注意してください。

ブラウザで/loginを開くと以下のような画面になります。

ログイン画面

7.4 コントローラの作成

それでは、実際にセッションを作成する部分に入ります。

app/controllers/sessions_controller.rbを以下のように実装します。

app/controllers/sessions_controller.rb

class SessionsController < ApplicationController
  def new
  end

  def create
    @user = User.find_by(email: params[:session][:email].downcase)
    if @user && @user.authenticate(params[:session][:password])
      session[:user_id] = @user.id
      flash[:info] = "logged in as #{@user.name}"
      redirect_to @user
    else
      flash[:danger] = 'invalid email/password combination'
      render 'new'
    end
  end
  
  def destroy
    session[:user_id] = nil
    redirect_to root_path
  end
end
ここで、先ほど入力したメールアドレスとパスワードはparams[:session]に入っています。

ログイン処理のcreateアクションでは以下のようなことを行っています。

ユーザーをメールアドレスから検索します。
もしユーザーが見つかった場合は、authenticateメソッドでパスワードが正しいか調べます。
パスワードが正しい場合は、session[:user_id]にユーザーIDを入れ、ユーザーの詳細ページにリダイレクトします。
パスワードが間違っている場合は’new’テンプレートを表示します。
ログアウト処理のdestroyアクションでは以下のようなことを行っています。

session[:user_id]をnilにしています。これでサーバーとブラウザの両方でセッションの情報が破棄されます。
アプリケーションのルート/にリダイレクトします。
7.5 ヘルパメソッドの追加

ここで、現在のログインしているユーザーを返すcurrent_userメソッドと、logged_in?メソッドをヘルパモジュールのSessionsHelperに定義します。
app/helpers/sessions_helper.rbを以下のように作成します。

app/helpers/sessions_helper.rb

module SessionsHelper
  def current_user
    @current_user ||= User.find_by(id: session[:user_id])
  end

  def logged_in?
    !!current_user
  end

  def store_location
    session[:forwarding_url] = request.url if request.get?
  end
end
current_userメソッドでは以下のようなことを行っています。

ログイン中の場合はログインしているユーザーを、ログインしていない場合はnilを返します。

||=は左の値がfalseかnilの場合に右の値の代入を行います。変数を初期化する際によく用いられます。
@current_user = @current_user || User.find_by(id: session[:user_id])と読み替えることができ、@current_userがnilのときに、User.find_by(id: session[:user_id])を実行します。
User.find_by(id: session[:user_id])は、session[:user_id]の値に一致するユーザーを返します。find_byメソッドは、ユーザーが見つからない場合はnilを返します。
したがって、session[:user_id]に一致するユーザーが存在する場合は@current_userにログイン中のユーザー（現在のユーザー）が入り、nilの場合は@current_userにnilが入ります。
メソッド中の最後の値が代入文の場合は、代入文を実行した後の左の値を返すので、current_userメソッドは@current_userの値を返します。
||=で代入を行っているので、左側の@current_userに値が入っている場合は、右側のUser.find_byで始まる処理は実行されません。すなわち、ログインしているユーザーを毎回DBに取りに行かなくてすみます。
logged_in?メソッドでは以下のようなことを行っています。

current_userが存在する場合はtrueを、nilの場合はfalseを返します。
!!は、右側に続く値が存在する場合はtrueを、nilの場合はfalseを返します。
これは、否定演算子!を二回つかったものと考えることができます。
current_userが存在する場合、!current_userがfalseになり、もう一度!をつけるとfalseが反転してtrueになります。
current_userがnilの場合、!current_userがtrueになり、もう一度!をつけるとtrueが反転してfalseになります。
store_locationメソッドでは以下のようなことを行っています。

リクエストがGETの場合は、session[:forwarding_url]にリクエストのURLを代入しています。
ログインが必要なページにアクセスしようとした際に、ページのURLを一旦保存しておき、ログイン画面に遷移してログイン後に再び保存したURLにアクセスする場合にこのメソッドを使用します。
慣れるまでは難しいと思いますが、特に||=と、!!はRubyでよく使われる書き方なので処理を追いながら覚えておいてください。

また、これらのメソッドをコントローラから使えるように、app/controllers/application_controller.rbを以下のように設定します。

app/controllers/application_controller.rb

class ApplicationController < ActionController::Base
  protect_from_forgery with: :exception
  include SessionsHelper

  private
  def logged_in_user
    unless logged_in?
      store_location
      flash[:danger] = "Please log in."
      redirect_to login_url
    end
  end
end
include SessionsHelperで、先ほどのSessionsHelperモジュールを読み込んでいます。

ここで、logged_in_userメソッド内では以下のような処理を行っています。

ログインしていない場合（logged_in?がfalseのとき）のみ処理を行います。
store_locationメソッドで、アクセスしようとしたURLを保存しています。
ログイン画面のURLにリダイレクトします。
7.6 ナビゲーションの追加

app/views/layouts/_header.html.erbを以下のように編集します。

app/views/layouts/_header.html.erb

<header class="navbar navbar-fixed-top navbar-inverse">
  <div class="container">
    <%= link_to "Microposts", root_path, id: "logo" %>
    <nav>
      <ul class="nav navbar-nav navbar-right">
        <li><%= link_to "Home", root_path %></li>
        <li><%= link_to "Help", '#' %></li>
        <% if logged_in? %>
          <li><%= link_to "Users", '#' %></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">
              Account <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
              <li><%= link_to "Profile", current_user %></li>
              <li><%= link_to "Settings", '#' %></li>
              <li class="divider"></li>
              <li>
                <%= link_to "Log out", logout_path, method: "delete" %>
              </li>
            </ul>
          </li>
        <% else %>
          <li><%= link_to "Log in", login_path %></li>
        <% end %>
      </ul>
    </nav>
  </div>
</header>
この部分はBootstrapのナビゲーションバーを使用しているのでBootstrapのレッスンを参考にしてください。

これで、準備ができました。トップ画面から’Log in’のボタンをクリックして、メールアドレスとパスワードを入力してログインできることを確認してください。
無事にログインできたら、今度は’Account’のメニューから’Log out’を選択してログアウトできるか試してみてください。

課題：ユーザーのプロフィール更新

ここまで出来たら動作確認を行ってください。動作確認ができたら新しいブランチを作成します。名前は、user-profileとしてください。

ユーザーがログインできるだけでなく、Twitterのように基本情報（プロフィール、メールアドレス、地域など）を更新できるようにしてください。

基本情報の編集画面はUsersControllerのeditに、更新処理はupdateにそれぞれアクションを割り当てます。
基本情報の編集と更新は、ログインしているユーザーが、自分のもののみできるようにします。

完成したらGitHubにブランチをプッシュして、リポジトリ名(microposts)とブランチ名(user-profile)を選択してコメントを追加して提出をおこなってください。

※ 課題提出後はmasterブランチに戻って作業を行ってください。
※ コードレビューで合格になった後に、user-profileブランチをmasterブランチにマージしてください。

課題提出済み（レビュー待ち）
8. 投稿機能

ユーザーの新規登録とログイン・ログアウトができるようになったので、投稿ができるように実装していきます。

8.1 モデルの作成

Micropostモデルを作成するには、ターミナルで以下のコマンドを実行します。

$ rails generate model Micropost user:references content:text
ここで、userにreferencesを指定することにより関連付けを持ち、contentにtextを指定することで、テキスト形式のデータを保存できるようにします。

生成されたマイグレーションファイルは以下のようになっています。

db/migrate/2015XXXXXXXXXX_create_microposts.rb

class CreateMicroposts < ActiveRecord::Migration
  def change
    create_table :microposts do |t|
      t.references :user, index: true, foreign_key: true
      t.text :content

      t.timestamps null: false
    end
  end
end
t.references :user, index: true, foreign_key: trueの行は以下のことを行います。

user_idという外部キーをカラムに追加します。これによって、ユーザーと投稿が関連付けられます。
index: trueを指定することで、user_idに対してインデックスを作成し、指定したユーザーの投稿を高速に検索することができるようになります。
foreign_key: trueを指定することで、外部キー制約を設定して、usersテーブルに存在するidのみuser_idに入るようにしています。
今後、ユーザーの投稿を作成時間の降順で並び替えることが多くなるので、さらにインデックスを追加します。
t.timestamps null: falseの下に以下の行を追加してください。

t.index [:user_id, :created_at]
これは複合インデックスと呼ばれ、投稿を指定ユーザーで絞り込んだ後、作成時間で検索や並び替えを行うという処理がより速く行えるようになります。

上記の内容で保存したら、マイグレーションを実行します。

$ rake db:migrate
バリデーションの追加

登録できるデータのチェックを行うために、Micropostモデルのファイルapp/models/micropost.rbを開き、以下のようにバリデーションを追加します。

app/models/micropost.rb

class Micropost < ActiveRecord::Base
  belongs_to :user
  validates :user_id, presence: true
  validates :content, presence: true, length: { maximum: 140 }
end
ここでは、以下のバリデーションを行うようにしています。

user_idが存在する。
contentが存在し、また、文字数は最大140。
8.2 ユーザーと投稿の関連づけ

ここで、Userモデルに以下のようにhas_many :micropostsを追加します。

app/models/user.rb

class User < ActiveRecord::Base
  ...
  has_many :microposts
end
Micropostモデルが生成される際にbelongs_to :userが指定されたので、ユーザーと投稿の関連づけは以下のようになっています。

それぞれのユーザーは複数の投稿を持つことができる。（has_many :microposts）
それぞれの投稿は特定の1人のユーザーのものである。（belongs_to :user）
userとmicropostの関連を図示すると、以下のようになっています。



また、has_many :micropostsとbelongs_to :userを追加することで、railsは以下のメソッドを自動的に生成します。

メソッド	用途
user.microposts	ユーザーの全投稿
micropost.user	投稿に関連付けられたユーザー
user.micropostsを用いて、ユーザーの投稿を新たに作成するには、以下のメソッドを使用できます。

メソッド	用途
user.microposts.new	ユーザーの投稿を作成
user.microposts.create	ユーザーの投稿を作成して保存
上記のメソッドを使うことで、userオブジェクトが関連付けられた状態でmicropostオブジェクトを作成、保存することができます。
これらはRailsで関連付けがあるオブジェクトを作成するやり方なのでよく覚えておきましょう。

8.3 コントローラとルートの作成

それでは、実際に投稿できるようにします。以下のコマンドでコントローラを生成します。

$ rails generate controller Microposts
app/controllers/microposts_controller.rbは以下のような内容にします。

app/controllers/microposts_controller.rb

class MicropostsController < ApplicationController
  before_action :logged_in_user, only: [:create]

  def create
    @micropost = current_user.microposts.build(micropost_params)
    if @micropost.save
      flash[:success] = "Micropost created!"
      redirect_to root_url
    else
      render 'static_pages/home'
    end
  end
  
  private
  def micropost_params
    params.require(:micropost).permit(:content)
  end
end
ここで、MicropostsControllerは以下のようなことをしています。

2行目のbefore_actionで、ApplicationControllerにあるlogged_in_userメソッドを実行し、ログインしていない場合はcreateメソッドは実行しないで/loginにリダイレクトするようにしています。
4行目からのcreateメソッドでは、パラメータを受け取って現在のユーザーに紐付いたMicropostのインスタンスを作成して@micropost変数に入れ、@micropost.saveで保存が成功した場合は、root_urlである/にリダイレクトを行い、失敗した場合はapp/views/static_pages/home.html.erbのテンプレートを表示します。
15行目のmicropost_paramsでは、フォームから受け取ったパラメータのparams[:micropost]のうち、params[:micropost][:content]のみデータの作成に使用するようにStrong Parametersを宣言しています。
次にconfig/routes.rbを以下のように修正します。

config/routes.rb

Rails.application.routes.draw do
  ...
  resources :microposts
end
8.4 フォームの作成

ここでは、Twitterと同じようにホーム画面に投稿フォームを設置します。
app/views/static_pages/home.html.erbを以下のように編集して、保存してください。

app/views/static_pages/home.html.erb

<% if logged_in? %>
  <div class="row">
    <aside class="col-md-4">
      <section class="user_info">
        <%= render 'shared/user_info' %>
      </section>
      <section class="micropost_form">
        <%= render 'shared/micropost_form' %>
      </section>
    </aside>
  </div>
<% else %>
  <div class="center jumbotron">
    <h1>Welcome to the Microposts</h1>

    <%= link_to "Sign up now!", signup_path, class: "btn btn-lg btn-primary" %>
  </div>
<% end %>
app/views/shared/_user_info.html.erbを以下の内容で作成します。

app/views/shared/_user_info.html.erb

<%= link_to gravatar_for(current_user, size: 50), current_user %>
<h1><%= current_user.name %></h1>
<span><%= link_to "view my profile", current_user %></span>
<span><%= pluralize(current_user.microposts.count, "micropost") %></span>
app/views/shared/_micropost_form.html.erbを以下の内容で作成します。

app/views/shared/_micropost_form.html.erb

<%= form_for(@micropost) do |f| %>
  <%= render 'shared/error_messages', object: f.object %>
  <div class="field">
    <%= f.text_area :content, placeholder: "Compose new micropost..." %>
  </div>
  <%= f.submit "Post", class: "btn btn-primary" %>
<% end %>
f.text_areaを指定することで、<input>よりも広い、テキスト入力用の<textarea>タグを出力します。また、placeholderをオプションに渡すことで、テキスト入力欄に仮の文字列を表示します。

app/assets/stylesheets/custom.scssに以下のスタイルを追加します。

app/assets/stylesheets/custom.scss

/* sidebar */

aside {
  section.user_info {
    margin-top: 20px;
  }
  section {
    padding: 10px 0;
    margin-top: 20px;
    &:first-child {
      border: 0;
      padding-top: 0;
    }
    span {
      display: block;
      margin-bottom: 3px;
      line-height: 1;
    }
    h1 {
      font-size: 1.4em;
      text-align: left;
      letter-spacing: -1px;
      margin-bottom: 3px;
      margin-top: 0px;
    }
  }
}

.gravatar {
  float: left;
  margin-right: 10px;
}

.gravatar_edit {
  margin-top: 15px;
}